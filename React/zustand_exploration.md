# zustand는 모든 상태 관리에 적합할까? 메모리, 저장소, 그리고 대안 비교?

## 📋 목차

1. [🧐 이 주제를 탐구하게 된 배경](#-이-주제를-탐구하게-된-배경)
2. [zustand는 어디에 저장될까?](#zustand는-어디에-저장될까)
   - [저장소 비교](#저장소-비교)
3. [zustand 메모리 사용량 확인](#zustand-메모리-사용량-확인)
   - [브라우저 메모리 측정](#브라우저-메모리-측정)
   - [zustand의 상태 객체 크기 측정](#zustand의-상태-객체-크기-측정)
4. [zustand 상태 관리가 힙 메모리를 초과할 가능성](#zustand-상태-관리가-힙-메모리를-초과할-가능성)
5. [JavaScript 힙 크기 초과 시 동작](#javascript-힙-크기-초과-시-동작)
6. [zustand 메모리 사용량 관리](#zustand-메모리-사용량-관리)
7. [zustand에 저장하기 적합한 데이터 요약](#zustand에-저장하기-적합한-데이터-요약)
8. [zustand를 사용하는 경우가 적합한 상황](#zustand를-사용하는-경우가-적합한-상황)
9. [zustand 없이 상태를 관리하는 것이 적합한 경우](#zustand-없이-상태를-관리하는-것이-적합한-경우)

## 🧐 이 주제를 탐구하게 된 배경

회사에서 **React**를 사용하여 특정 계산 앱을 개발 중인 동료가 계셨습니다.

이 앱은 계산에 필요한 값이 **JSON 파일**에 저장되어 있었고,  
**계산 로직은 별도의 파일에 작성된 함수**로 관리되었습니다.

이 함수를 **zustand**에서 호출해 계산된 결과를 상태로 저장하고,  
페이지에서는 해당 상태를 호출해 사용하는 방식으로 구현되었습니다.

그런데 대화를 나누던 중,  
**“저장할 값도 많고 계산식도 복잡한 상황에서 zustand에 모든 것을 넣어 관리하는 것이 적합한가?”**  
라는 의문이 제기되었습니다.

이를 계기로 **zustand 사용의 적합성**과 **대안적인 방법**을 탐구하게 되었습니다. 🔍✨

---

## zustand는 어디에 저장될까?

- **기본 설정**: 상태는 JavaScript 힙 메모리(Heap Memory)에 저장되며, 앱 실행 중에만 유지됩니다.
- **persist 미들웨어**:
  - **localStorage**: 브라우저 종료 후에도 상태가 유지됩니다.
  - **sessionStorage**: 탭이 열려 있는 동안만 상태가 유지됩니다.
  - **사용자 정의 저장소**: 필요에 따라 IndexedDB, 서버, 쿠키 등을 활용할 수 있습니다.

### 저장소 비교

| 저장소             | 새로 고침 후 유지 | 탭 닫기 후 유지 | 용도                        |
| ------------------ | ----------------- | --------------- | --------------------------- |
| **메모리**         | ❌                | ❌              | 앱 실행 중 임시 상태 관리.  |
| **localStorage**   | ✅                | ✅              | 브라우저 종료 후에도 유지.  |
| **sessionStorage** | ✅                | ❌              | 탭이 열려 있는 동안만 유지. |

---

## zustand 메모리 사용량 확인

### 브라우저 메모리 측정

브라우저에서 현재 메모리 사용량을 간단히 확인할 수 있는 `window.performance.memory`를 사용할 수 있습니다.
다만, 이 API는 **Chrome**과 일부 Chromium 기반 브라우저에서만 작동합니다.

#### 설명

- **`jsHeapSizeLimit`**: 브라우저에서 사용할 수 있는 JavaScript 힙 메모리의 최대 크기.
- **`totalJSHeapSize`**: 현재 할당된 메모리 크기.
- **`usedJSHeapSize`**: 실제로 사용 중인 메모리 크기.

```javascript
if (performance.memory) {
  console.log("JS Heap Size Limit:", performance.memory.jsHeapSizeLimit); // 브라우저 힙 메모리 최대값
  console.log("Total Heap Size:", performance.memory.totalJSHeapSize); // 총 할당된 힙 메모리
  console.log("Used Heap Size:", performance.memory.usedJSHeapSize); // 실제 사용 중인 힙 메모리
} else {
  console.log("Memory API not supported in this browser.");
}
```

#### 예제 출력

```
JS Heap Size Limit: 4294705152
Total Heap Size: 50000000
Used Heap Size: 25000000
```

### **zustand의 상태 객체 크기 측정**

zustand의 상태 객체가 얼마나 메모리를 차지하는지 대략적으로 추정하려면 객체를 JSON 문자열로 변환해 크기를 확인할 수 있습니다.

```javascript
const useStore = create((set) => ({
  count: 0,
  items: Array(1000).fill({ key: "value" }), // 예시로 큰 데이터
}));

const state = useStore.getState();
const stateSize = new Blob([JSON.stringify(state)]).size;

console.log(`State size: ${stateSize} bytes`);
```

**참고 사항**

- `zustand` 상태만의 메모리 사용량은 정확히 추적하기 어렵습니다. 이는 브라우저 메모리 관리가 동적이고, JavaScript 힙 외에도 다양한 메모리를 사용하기 때문입니다.
- 메모리 누수를 방지하려면 사용하지 않는 상태나 리소스를 적절히 정리해야 합니다.

---

## zustand 상태 관리가 힙 메모리를 초과할 가능성

- 일반적인 애플리케이션에서는 zustand 상태로 힙 메모리 제한을 초과할 가능성은 낮습니다.
- 그러나:
  - 매우 큰 배열(수백만 개 이상의 항목)을 zustand 상태로 관리하면 메모리 사용량이 빠르게 증가할 수 있습니다.
  - 상태가 지나치게 커질 가능성이 있다면 **IndexedDB**나 **localStorage** 같은 저장소와 함께 사용하는 것을 고려해야 합니다.

---

## JavaScript 힙 크기 초과 시 동작

- 상태 크기가 힙 메모리 제한을 초과하면:
  - 브라우저에서 **Out of Memory** 오류 발생.
  - 애플리케이션이 중단되거나, 메모리가 해제되지 않아 브라우저가 비정상 종료될 수 있습니다.

---

## zustand 메모리 사용량 관리

1. **메모리 누수 방지**:

   - 오래된 상태나 불필요한 데이터를 유지하지 않도록 `zustand`의 상태를 적절히 초기화하세요.
   - 예: 특정 작업이 끝난 후 상태를 초기화.
     ```javascript
     useStore.setState({ count: 0, items: [] });
     ```

2. **상태 크기 제한**:

   - `zustand` 상태는 필요 최소한의 데이터를 저장하도록 설계해야 합니다.
   - 예: 큰 배열이나 객체 대신 참조 ID, 키 등을 저장.

3. **중복 상태 제거**:
   - 이미 서버에 저장된 데이터를 `zustand`에 불필요하게 중복 저장하지 않도록 설계.

---

## zustand에 저장하기 적합한 데이터 요약

| 데이터 유형               | zustand 저장 적합성 | 추천 이유                                        |
| ------------------------- | ------------------- | ------------------------------------------------ |
| 전역적으로 사용되는 상태  | ✅                  | 여러 컴포넌트에서 공유되므로 적합.               |
| 간단한 UI 상태            | ✅                  | 컴포넌트 간 공유가 필요한 경우 적합.             |
| 큰 배열, 대용량 객체      | ❌                  | 메모리 사용량 과다로 비효율적.                   |
| 사용자 환경 설정          | ✅ (persist 필요)   | persist 미들웨어를 통해 영구 저장 가능.          |
| 특정 컴포넌트 내부의 상태 | ❌                  | React의 `useState`가 더 적합.                    |
| 정적 데이터               | ❌                  | 상수 파일이나 React Context로 관리.              |
| 비동기 서버 데이터        | ❌                  | zustand와 비동기 상태 관리 라이브러리 병용 추천. |

---

## zustand를 사용하는 경우가 적합한 상황

1. 전역 상태 관리:

   - 여러 컴포넌트에서 데이터를 공유하거나 동기화해야 하는 경우.
   - 예: 인증 상태, 사용자 설정, 쇼핑 카트 등.

2. 상태가 자주 변경:

   - 상태가 자주 변경되며, 여러 컴포넌트에서 상태 변경에 반응해야 할 때.
   - 예: 로딩 상태, 페이지 간 데이터 공유.

3. 복잡한 계산 로직이 포함된 경우:

   - 계산 결과가 전역적으로 필요하며, 이를 효율적으로 관리해야 하는 경우.

4. React Context의 단점 극복:

   - React Context는 컴포넌트 트리 깊숙이 상태를 전달할 수 있지만, 구독 단위가 크기 때문에 zustand의 선택적 구독(selector) 기능이 더 효율적일 수 있음.

---

## zustand 없이 상태를 관리하는 것이 적합한 경우

1. 로컬 상태만 필요한 경우:

   - 상태가 컴포넌트 내에서만 사용되고, 다른 컴포넌트와 공유할 필요가 없는 경우.

2. 간단한 계산과 데이터:

   - 데이터를 단순히 계산하여 보여주는 UI.

3. 데이터 변경이 자주 발생하지 않는 경우:
   - 정적인 데이터로 동작하거나 계산식이 적은 경우.
4. 복잡한 전역 상태 관리가 필요 없는 경우:

   - Zustand, Redux 같은 상태 관리 라이브러리의 오버헤드가 불필요한 상황.
